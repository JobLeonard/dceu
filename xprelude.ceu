;; ARITHMETIC:  +  -  *  /  %  **  //

func {+} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number ($v1.Number + $v2.Number)`
}

func {-} (v1, v2) {
    ifs {
        (v1 is :number) and (v2 is :nil) -> {
            `:number (- $v1.Number)`
        }
        (v1 isnot :number) or (v2 isnot :number) -> {
            throw(:error)
        }
        else -> {
            `:number ($v1.Number - $v2.Number)`
        }
    }
}

func {*} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number ($v1.Number * $v2.Number)`
}

func {**} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number powf($v1.Number, $v2.Number)`
}

func {/} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number ($v1.Number / $v2.Number)`
}

func {//} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number powf($v1.Number, 1/$v2.Number)`
}

func {%} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number fmod($v1.Number, $v2.Number)`
}

;; RELATIONAL:  >=  >  <=  <

func {>=} (v1,v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:bool ($v1.Number >= $v2.Number)`
}

func {>} (v1,v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:bool ($v1.Number > $v2.Number)`
}

func {<=} (v1,v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:bool ($v1.Number <= $v2.Number)`
}

func {<} (v1,v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:bool ($v1.Number < $v2.Number)`
}

func is' (v1,v2) {
    ifs {
        (v1 == v2)         -> true
        (type(v2) /= :tag) -> false
        (type(v1) == v2)   -> true
        tags(v1,v2)        -> true
        else -> false
    }
}

func isnot' (v1,v2) {
    not is'(v1,v2)
}
