;; is', isnot'

func is' (v1,v2) {
    ifs {
        (v1 == v2)         -> true
        (type(v2) /= :tag) -> false
        (type(v1) == v2)   -> true
        tags(v1,v2)        -> true
        else -> false
    }
}

func isnot' (v1,v2) {
    not is'(v1,v2)
}

;; ARITHMETIC:  +  -  *  /  %  **  //

func {+} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number ($v1.Number + $v2.Number)`
}

func {-} (v1, v2) {
    ifs {
        (v1 is :number) and (v2 is :nil) -> {
            `:number (- $v1.Number)`
        }
        (v1 isnot :number) or (v2 isnot :number) -> {
            throw(:error)
        }
        else -> {
            `:number ($v1.Number - $v2.Number)`
        }
    }
}

func {*} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number ($v1.Number * $v2.Number)`
}

func {**} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number powf($v1.Number, $v2.Number)`
}

func {/} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number ($v1.Number / $v2.Number)`
}

func {//} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number powf($v1.Number, 1/$v2.Number)`
}

func {%} (v1, v2) {
    if (v1 isnot :number) or (v2 isnot :number) {
        throw(:error)
    }
    `:number fmod($v1.Number, $v2.Number)`
}

;; RELATIONAL:  >=  >  <=  <

func {>} (v1,v2) {
    ifs {
        (v1 is :tag)    and (v2 is :tag)    -> `:bool ($v1.Tag    > $v2.Tag)`
        (v1 is :number) and (v2 is :number) -> `:bool ($v1.Number > $v2.Number)`
        else -> throw(:error)
    }
}

func {<} (v1,v2) {
    not ((v1 == v2) or (v1 > v2))
}

func {>=} (v1,v2) {
    (v1 == v2) or (v1 > v2)
}

func {<=} (v1,v2) {
    (v1 == v2) or (v1 < v2)
}

;; ASSERT

func assert (v, msg) {
    if not v {
        print("assertion error : ")
        println(msg or "no reason given")
        throw(:assert)
    }
}

;; TAG-OR

func tag-or (t1,t2) {
    assert(type(t1) == :tag)
    assert(type(t2) == :tag)
    `:tag $t1.Tag | $t2.Tag`
}

;; max, min

func min (v1, v2) {
    ((v1 < v2) and v1) or v2
}

func max (v1, v2) {
    ((v1 > v2) and v1) or v2
}

;; tostring, tonumber

func c-to-string (v) {
    assert(type(v) == :pointer)
    val str = #[]
    while in [0 -> `:number strlen($v.Pointer)`), i {
        set str[+] = `:char ((char*)$v.Pointer)[(int)$i.Number]`
    }
    move(str)
}

func to-string (v) {
    ifs v {
        is :pointer -> c-to-string(v)
        is :tag -> c-to-string(`:pointer ceu_tag_to_string($v.Tag)`)
        is :number -> {
            ```
            static char str[255];
            snprintf(str, 255, "%g", $v.Number);
            ```
            to-string(`:pointer str`)
        }
        else -> v   ;; TODO
    }
}

func to-number (v) {
    ifs v {
        is :tag -> `:number $v.Tag`
        ((v is :vector) and (#v > 0)) and (v[0] is :char) -> {
            `:number atoi($v.Dyn->Ncast.Vector.buf)`
        }
        else -> v   ;; TODO
    }
}

;;;
func to-tracks (...) {
    val ret = #[]
    while in :tuple ..., (_,v) {
        ifs v {
            is :x-task -> {
                set ret[+] = track(v)
            }
            is :x-tasks -> {
                while in :tasks v, i {
                    set ret[+] = i
                }
            }
        }
    }
    move(ret)
}
;;;

;; (++) concat

func {<++} (v1, v2) {
    assert(type(v1) == :vector)
    assert(type(v2) == :vector)
    do {
        while in [0 -> #v2), i {
            set v1[+] = v2[i]
        }
    }
    v1
}

func {++} (v1, v2) {
    (#[] <++ v1) <++ v2
}

;; to-vector

;;;
func to-vector (v) {
    ifs v {
        is :x-coro -> {
            val ret = #[]
            while in :coro v, vv {
                set ret[+] = vv
            }
            move(ret)
        }
        else -> throw(:TODO)
    }
}
;;;

;; composition

func {<|<} (^f,^g) {
    func (v) {
        ^^f(^^g(v))
    }
}

;; random-seed, random

func random-seed (n) {
    if n {
        `srand($n.Number);`
    } else {
        `srand(time(NULL));`
    }
}

func random-next () {
    `:number rand()`
}

;; ITERATORS

func iter-tuple (t) {
    val i = t.2
    if i >= #t.1 {
        nil
    } else {
        set t.2 = i + 1
        move([i, t.1[i]])
    }
}

func iter-dict (t) {
    val k = next(t.1,t.2)
    if k == nil {
        nil
    } else {
        set t.2 = k
        move([k, t.1[k]])
    }
}

func iter-coro (t) {
    val co = t.1
    if co.status == :terminated {
        nil
    }
    resume t.1()
}

func iter (v) {
    ifs v {
        is :tuple  -> [iter-tuple, v, 0]
        is :vector -> [iter-tuple, v, 0]
        is :dict   -> [iter-dict,  v, nil]
        is :x-coro -> [iter-coro,  v]
    }
}
