;; ARITHMETIC:  +  -  *  /  %  **  //

func {+} (v1, v2) {
    if (type(v1) /= :number) or (type(v2) /= :number) {
        throw(:error)
    }
    `:number ($v1.Number + $v2.Number)`
}

func {-} (v1, v2) {
    var t1 = type(v1)
    var t2 = type(v2)
    ifs {
        (t1 == :number) and (t2 == :nil) -> {
            `:number (- $v1.Number)`
        }
        (t1 /= :number) or (t2 /= :number) -> {
            throw(:error)
        }
        else -> {
            `:number ($v1.Number - $v2.Number)`
        }
    }
}

func {*} (v1, v2) {
    if (type(v1) /= :number) or (type(v2) /= :number) {
        throw(:error)
    }
    `:number ($v1.Number * $v2.Number)`
}

func {**} (v1, v2) {
    if (type(v1) /= :number) or (type(v2) /= :number) {
        throw(:error)
    }
    `:number powf($v1.Number, $v2.Number)`
}

func {/} (v1, v2) {
    if (type(v1) /= :number) or (type(v2) /= :number) {
        throw(:error)
    }
    `:number ($v1.Number / $v2.Number)`
}

func {//} (v1, v2) {
    if (type(v1) /= :number) or (type(v2) /= :number) {
        throw(:error)
    }
    `:number powf($v1.Number, 1/$v2.Number)`
}

func {%} (v1, v2) {
    if (type(v1) /= :number) or (type(v2) /= :number) {
        throw(:error)
    }
    `:number fmod($v1.Number, $v2.Number)`
}

;; RELATIONAL:  >=  >  <=  <

func {>=} (v1,v2) {
    var t1 = type(v1)
    if (t1 /= type(v2)) or (t1 /= :number) {
        throw(:error)
    }
    `:bool ($v1.Number >= $v2.Number)`
}

func {>} (v1,v2) {
    var t1 = type(v1)
    if (t1 /= type(v2)) or (t1 /= :number) {
        throw(:error)
    }
    `:bool ($v1.Number > $v2.Number)`
}

func {<=} (v1,v2) {
    var t1 = type(v1)
    if (t1 /= type(v2)) or (t1 /= :number) {
        throw(:error)
    }
    `:bool ($v1.Number <= $v2.Number)`
}

func {<} (v1,v2) {
    var t1 = type(v1)
    if (t1 /= type(v2)) or (t1 /= :number) {
        throw(:error)
    }
    `:bool ($v1.Number < $v2.Number)`
}
